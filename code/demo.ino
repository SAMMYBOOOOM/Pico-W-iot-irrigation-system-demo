// https://github.com/SAMMYBOOOOM/Pico-W-iot-irrigation-system-demo

#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <ArduinoJson.h>
#include <HTTPClient.h>
#include <LEAmDNS.h>
#include <NTPClient.h>
#include <PubSubClient.h>
#include <StreamString.h>
#include <WebServer.h>
#include <WiFi.h>
#include <WiFiClient.h>
#include <WiFiClientSecure.h>
#include <Wire.h>
#include <qrcode.h>

// OLED display dimensions
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64

Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);

// WiFi and other constants
const char *ssid = "";
const char *password = "";
#define MOISTURE_PIN A0 // Define the moisture sensor pin
#define EXTERNAL_BUTTON_PIN 16
#define RELAY_PIN 17

// Replace with your Line Channel Access Token
const char *accessToken = ""

    // Your Line User ID (required for push message)
    const char *userId = ""; // Replace with your LINE user ID

WiFiClientSecure lineClient;

// MQTT server settings
const char *mqttServer = ""; // MQTT server location
const int mqttPort = 1883;
const char *clientID = "";     // client ID
const char *mqttUserName = ""; // MQTT username (if any)
const char *mqttPwd = "";      // MQTT password (if any)
const char *topic = "";        // topic
const char *calltopic = "";    // call topic
unsigned long prevMillis = 0;  // previous timestamp
const long interval = 100;     // time interval in milliseconds
String msgStr = "";            // message string

const String commandSet[] = {"on", "off", "buttonstate", "moisture",
                             "coretemp"};
String commandStr = "";
bool commandReceived = false;
bool error = false;

// Taipei UTC +8
WiFiUDP ntpUDP;
NTPClient timeClient(ntpUDP, "europe.pool.ntp.org", 60 * 60 * 8, 60000);

WiFiClient wifiClient;
PubSubClient client(wifiClient);

WebServer server(80);
HTTPClient http;

const char *pythonServerIP = ""; // Replace with your computer's IP address
const int pythonServerPort = 5000;

const int led = LED_BUILTIN;
int pageCount = 0; // Counter for page views

// Arrays to store historical data
const int dataSize = 40;
float coreTempHistory[dataSize] = {0};
int moistureHistory[dataSize] = {0};
int moistureIndex = 0,
    coreTempIndex = 0, // Index to track the current position in the arrays
    buttonState = 0, totalButtonState = 4;

const unsigned char Frame1[] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xe0,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x0c, 0x30, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x03, 0xc0, 0x00, 0x10, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
    0xf0, 0x00, 0x10, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xbe, 0x00,
    0x18, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x87, 0xc0, 0x08, 0x62,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0xff, 0xfc, 0x02, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x05, 0x00, 0x1f, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0e, 0x00, 0x09, 0x03, 0x86, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfe,
    0x00, 0x09, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x6f, 0xfc, 0x00, 0x19,
    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x10, 0x80, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x10, 0x80, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xc0, 0x00, 0x00, 0x30, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x80, 0x00, 0x00, 0x20, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x20, 0x1c, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60,
    0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00};

const unsigned char Frame2[] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xf0, 0x00, 0x0c, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x3f, 0x00, 0x18, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xe0,
    0x10, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x3e, 0x10, 0x62,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x07, 0xf0, 0x02, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0xd8, 0x02, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x0a, 0x03, 0xce, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0a, 0x06, 0x83, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x0d,
    0x80, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xcc, 0x39, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x61, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x0f, 0x80, 0xc3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x09, 0x03, 0x82, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x06, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x02,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x02, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x03, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x60, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x78, 0x00, 0xe0, 0x00, 0x00, 0x00};

const unsigned char Frame3[] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x61, 0xc0,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x60, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x30, 0xff, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x02, 0x00, 0x19, 0x81, 0xc0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x02, 0x00, 0x1f, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06,
    0x00, 0x7e, 0x06, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0xd2,
    0x06, 0x20, 0x00, 0x00, 0x00, 0x10, 0x00, 0x08, 0x01, 0x92, 0x00, 0x60,
    0x00, 0x00, 0x00, 0x10, 0x00, 0x08, 0x01, 0x33, 0x00, 0xc0, 0x00, 0x00,
    0x00, 0x18, 0x00, 0x18, 0x03, 0x61, 0xe3, 0x00, 0x00, 0x00, 0x00, 0x0c,
    0x00, 0x10, 0x03, 0xc0, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x1f,
    0x86, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x7c, 0xfe, 0x80,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc1, 0xc7, 0xe5, 0x80, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x7f, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x1b, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3e, 0xf3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x37, 0xc6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xdb, 0xec,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xb8, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x03, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00};

const unsigned char Frame4[] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x61, 0xc0,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x60, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x30, 0xff, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x02, 0x00, 0x19, 0x81, 0xc0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x02, 0x00, 0x1f, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06,
    0x00, 0x7e, 0x06, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0xd2,
    0x06, 0x20, 0x00, 0x00, 0x00, 0x10, 0x00, 0x08, 0x01, 0x92, 0x00, 0x60,
    0x00, 0x00, 0x00, 0x10, 0x00, 0x08, 0x01, 0x33, 0x00, 0xc0, 0x00, 0x00,
    0x00, 0x18, 0x00, 0x18, 0x03, 0x61, 0xe3, 0x00, 0x00, 0x00, 0x00, 0x0c,
    0x00, 0x10, 0x03, 0xc0, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x1f,
    0x86, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x7c, 0xfe, 0x80,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc1, 0xc7, 0xe5, 0x80, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x7f, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x1b, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3e, 0xf3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x37, 0xc6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xdb, 0xec,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xb8, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x03, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00};

const unsigned char Frame5[] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf0, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0c, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x10, 0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xff, 0xf0, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe3, 0x30,
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x04, 0x18, 0x02, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x18, 0x1f, 0xfc, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0xc0, 0x60, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0f, 0x00, 0xc0, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00,
    0xe0, 0x00, 0x80, 0x00, 0x00, 0x00, 0x03, 0xff, 0xf8, 0x00, 0x38, 0x01,
    0x80, 0x00, 0x00, 0x00, 0x1e, 0x00, 0xf0, 0x00, 0x1e, 0x01, 0x00, 0x00,
    0x00, 0x00, 0x78, 0x01, 0xf0, 0x00, 0x03, 0xc3, 0x00, 0x00, 0x00, 0x00,
    0xc0, 0x03, 0x30, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06,
    0x30, 0x00, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x20, 0x00,
    0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x20, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xe0, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x20, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x20, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x20, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x3f, 0x00, 0x3f, 0x80, 0x00, 0x00, 0x00, 0x00};

const unsigned char Frame6[] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x18, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x10, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
    0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xf8, 0x32, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x03, 0x88, 0x02, 0x00, 0x00, 0x01,
    0xff, 0x00, 0x3e, 0x00, 0x02, 0xc4, 0x02, 0x00, 0x00, 0x0f, 0x01, 0xf8,
    0xe0, 0x00, 0x06, 0x62, 0x02, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0x00,
    0x04, 0x39, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x0c, 0x0e,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x07, 0xc1, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x78, 0x80, 0x00, 0x00, 0x00,
    0x00, 0x6c, 0x00, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x00, 0x00, 0xc8,
    0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0x03, 0x98, 0x00, 0x00,
    0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0x0e, 0x30, 0x00, 0x00, 0x00, 0x01,
    0x60, 0x00, 0x00, 0x00, 0xf8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x81, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x06, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

const unsigned char Frame7[] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x7f, 0xc0, 0x00, 0x00, 0x00,
    0x00, 0x0c, 0x18, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x08,
    0x04, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x1f, 0xff, 0xf0, 0x10, 0x62, 0x00,
    0x00, 0x00, 0x03, 0xc1, 0xf8, 0x00, 0x1f, 0xf8, 0x62, 0x00, 0x00, 0x00,
    0x00, 0x7f, 0x00, 0x00, 0x01, 0xd8, 0x02, 0x00, 0x00, 0x00, 0x00, 0x78,
    0x00, 0x00, 0x00, 0xc4, 0x02, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00,
    0x00, 0x63, 0x84, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x70,
    0xf8, 0x00, 0x00, 0x03, 0xff, 0x80, 0x00, 0x00, 0x00, 0x0c, 0xc0, 0x00,
    0x00, 0x1c, 0x06, 0x00, 0x00, 0x00, 0x00, 0x06, 0x3e, 0x00, 0x00, 0x30,
    0x1c, 0x00, 0x00, 0x00, 0x00, 0x03, 0x01, 0x80, 0x00, 0x00, 0x70, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x80, 0x40, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x40, 0x40, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x30, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00,
    0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

const unsigned char Frame8[] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xc0, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00,
    0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x01, 0x83,
    0x80, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x03, 0x00, 0xc0, 0x00,
    0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x03, 0x0c, 0x40, 0x00, 0x00, 0x00,
    0x00, 0xff, 0xff, 0xff, 0xe1, 0x0c, 0x60, 0x00, 0x00, 0x00, 0x00, 0xf0,
    0x00, 0x1f, 0xff, 0x80, 0x20, 0x00, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x01,
    0xf9, 0xe0, 0x20, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0xcc, 0x78,
    0x60, 0x00, 0x00, 0x03, 0xe7, 0x80, 0x00, 0x00, 0x64, 0x1f, 0xc0, 0x00,
    0x00, 0x0e, 0xff, 0x00, 0x00, 0x00, 0x66, 0x00, 0x00, 0x00, 0x00, 0x1c,
    0x0e, 0x00, 0x00, 0x00, 0x33, 0xf0, 0x00, 0x00, 0x00, 0x30, 0xf8, 0x00,
    0x00, 0x00, 0x18, 0x1f, 0xf0, 0x00, 0x00, 0x7f, 0xf0, 0x00, 0x00, 0x00,
    0x08, 0x00, 0x00, 0x00, 0x01, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00,
    0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
    0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x0e, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x86, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

const unsigned char Frame9[] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xc0, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00,
    0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x01, 0x83,
    0x80, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x03, 0x00, 0xc0, 0x00,
    0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x03, 0x0c, 0x40, 0x00, 0x00, 0x00,
    0x00, 0xff, 0xff, 0xff, 0xe1, 0x0c, 0x60, 0x00, 0x00, 0x00, 0x00, 0xf0,
    0x00, 0x1f, 0xff, 0x80, 0x20, 0x00, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x01,
    0xf9, 0xe0, 0x20, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0xcc, 0x78,
    0x60, 0x00, 0x00, 0x03, 0xe7, 0x80, 0x00, 0x00, 0x64, 0x1f, 0xc0, 0x00,
    0x00, 0x0e, 0xff, 0x00, 0x00, 0x00, 0x66, 0x00, 0x00, 0x00, 0x00, 0x1c,
    0x0e, 0x00, 0x00, 0x00, 0x33, 0xf0, 0x00, 0x00, 0x00, 0x30, 0xf8, 0x00,
    0x00, 0x00, 0x18, 0x1f, 0xf0, 0x00, 0x00, 0x7f, 0xf0, 0x00, 0x00, 0x00,
    0x08, 0x00, 0x00, 0x00, 0x01, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00,
    0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
    0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x0e, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x86, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

const unsigned char *epd_bitmap_allArray[9] = {
    Frame1, Frame2, Frame3, Frame4, Frame5, Frame6, Frame7, Frame8, Frame9};

void setup() {
  pinMode(led, OUTPUT);
  pinMode(RELAY_PIN, OUTPUT);
  digitalWrite(RELAY_PIN, HIGH);
  digitalWrite(led, 0);
  Serial.begin(115200);
  while (!Serial)
    ;

  // Wait for connection
  connectWiFi();

  client.setServer(mqttServer, mqttPort);
  client.setCallback(callback);

  connectMQTT();

  lineClient.setInsecure();

  if (MDNS.begin("picow")) {
    Serial.println("MDNS responder started");
  }

  server.on("/", handleRoot);
  server.on("/coreTemperature", handleCoreTemperature);
  server.on("/moistureValue", handleMoistureValue);
  server.on("/test.svg", drawGraph);
  server.on("/imageStream", handleImageStream);
  server.on("/imageFeed", imageFeed);
  server.on("/webhook", HTTP_POST,
            handleWebhook); // Handle incoming line messages
  server.onNotFound(handleNotFound);
  server.begin();
  Serial.println("HTTP server started");

  // Send a test message
  sendMessage("Hello from Pico W!");
  mqttStr("Pico W is currently booting up...");
}

void loop() {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("Reconnecting to WiFi...");
    connectWiFi();
  }
  if (!client.connected()) {
    Serial.println("Reconnecting to MQTT...");
    connectMQTT();
  }
  client.loop();

  MDNS.update();

  timeClient.update();
  msgStr = convertEpochTime(timeClient.getEpochTime()) + " " +
           timeClient.getFormattedTime();

  readSensorValues();
}

void setup1() {
  // Initialize button state
  pinMode(EXTERNAL_BUTTON_PIN, INPUT_PULLDOWN);

  // Initialize OLED display
  Wire.setSDA(8);
  Wire.setSCL(9);
  Wire.begin();
  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.cp437(true);

  display.setCursor(0, 0);
  display.println("Connecting to wifi...");
  display.setCursor(0, 16);
  display.println("Made by: SAMMYBOOOOM on github");
  display.startscrollleft(0x00, 0x00);
  display.display();

  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
  }

  display.stopscroll();
  display.clearDisplay();
}

void loop1() {
  // Handle OLED display updates
  oledDisplay();

  // Handle external button state
  externalButton();

  // Handle MQTT message processing
  if (commandStr.length() > 1) {
    commandHandler();
  }

  // Handle HTTP server requests
  server.handleClient();
}

void readSensorValues() {
  // Record sensor value periodically
  static unsigned long lastRecordTime = 0;

  if (millis() - lastRecordTime >= 1000) { // Record every 1 second
    lastRecordTime = millis();
    coreTempHistory[coreTempIndex] = analogReadTemp();
    moistureHistory[moistureIndex] = analogRead(MOISTURE_PIN);

    moistureIndex = (moistureIndex + 1) % dataSize;
    coreTempIndex = (coreTempIndex + 1) % dataSize;
  }
}

void oledDisplay() {
  display.clearDisplay();

  String oledDisplay;
  switch (buttonState) {
  case 0:
    if (!moistureIndex) {
      oledDisplay = "Moisture: " + String(moistureHistory[dataSize - 1]);
    } else {
      oledDisplay = "Moisture: " + String(moistureHistory[moistureIndex - 1]);
    }
  case 1:
    if (buttonState) {
      if (!coreTempIndex) {
        oledDisplay = "Core: " + String(coreTempHistory[dataSize - 1]);
      } else {
        oledDisplay = "Core: " + String(coreTempHistory[coreTempIndex - 1]);
      }
    }
    display.setCursor(0, 0);
    display.println("Button State: (" + String(buttonState) + ")");
    display.setCursor(0, 16);
    display.write(oledDisplay.c_str());
    if (buttonState) {
      display.write(' ');
      display.write(248);
      display.write('C');
    }
    display.setCursor(0, 32);
    display.write(msgStr.c_str());
    display.display();
    break;
  case 2:
    static int frameIndex = 0;
    display.drawBitmap(0, 0, epd_bitmap_allArray[frameIndex], 80, 32, 1);
    display.setCursor(0, 32);
    display.write(msgStr.c_str());
    display.setCursor(0, 48);
    oledDisplay = "RAM: " + String(rp2040.getFreeHeap()) + "Bytes";
    display.write(oledDisplay.c_str());
    display.display();
    frameIndex = (frameIndex + 1) % 9;
    break;
  }

  while (buttonState == 3) {
    Serial.println("buttonState lock: " + String(buttonState));
    generateQRCode(
        "https://github.com/SAMMYBOOOOM/Pico-W-iot-irrigation-system-demo");
    externalButton();
    delay(200);
  }
  while (buttonState >= totalButtonState) {
    Serial.println("buttonState not found: " + String(buttonState));
    if (!error) {
      buttonStateNotFound();
      error = true;
    }
    externalButton();
    delay(200);
  }
}

void externalButton() {
  static unsigned long firstPressTime = 0;

  if (digitalRead(EXTERNAL_BUTTON_PIN) == HIGH &&
      millis() - firstPressTime > 400) {
    firstPressTime = millis();
    display.clearDisplay();
    display.setCursor(0, 0);
    display.println("Press the button(" + String(buttonState) + ")");
    // display.startscrollleft(0x00, 0x00);
    display.display();

    error = false;
    display.setTextSize(1);
    display.stopscroll();
    buttonState = (buttonState + 1) % totalButtonState;
    Serial.println("buttonState: " + String(buttonState));
  }
}

void buttonStateNotFound() {
  display.clearDisplay();
  display.setCursor(0, 0);
  display.println("buttonState not found       (" + String(buttonState) + ")");
  display.setCursor(0, 16);
  display.setTextSize(3);
  display.write(174);
  display.write("ERROR");
  display.write(175);
  display.setCursor(0, 42);
  display.write("OR");
  display.write(174);
  display.write(175);
  display.write("ERR");
  display.startscrollleft(0x02, 0x0F);
  display.display();

  sendMessage("buttonState not found (" + String(buttonState) +
              "), please reset manually");
  mqttStr("buttonState not found (" + String(buttonState) +
          "), please reset manually");
}

void commandHandler() {
  // Handle commands
  bool commandFromWebhook = false;
  if (commandStr[0] == 'L') {
    commandFromWebhook = true;
  }
  commandStr = commandStr.substring(1);

  int size = commandStr.length(), num;
  String temp = "", numStr = "";
  for (int i = 0; i < size; i++) {
    char currentChar = commandStr.charAt(i);
    if (currentChar == '\n') {
      break;
    }
    if (currentChar == ' ') {
      continue;
    }
    if (currentChar >= 'A' && currentChar <= 'Z') {
      currentChar += 32;
    }
    if (currentChar >= '0' && currentChar <= '9') {
      numStr += currentChar;
      continue;
    }
    temp += currentChar;
  }

  num = numStr.toInt();
  commandStr = temp;

  int commandCount = sizeof(commandSet) / sizeof(commandSet[0]);
  for (int i = 0; i < commandCount; i++) {
    // Check for exact match or match of the first four letters
    if (temp == commandSet[i] ||
        temp.substring(0, 4) == commandSet[i].substring(0, 4)) {
      Serial.print("Command found at index: ");
      Serial.println(i);
      switch (i) {
      case 0:
        digitalWrite(led, HIGH);
        digitalWrite(RELAY_PIN, LOW);
        break;
      case 1:
        digitalWrite(led, LOW);
        digitalWrite(RELAY_PIN, HIGH);
        break;
      case 2:
        buttonState = num;
        break;
      case 3:
        break;
      case 4:
        break;
      }
      commandReply(i, commandFromWebhook);
      break;
    }
  }

  commandStr = "";
}

void commandReply(int index, bool fromWebhook) {
  String reply = "";

  switch (index) {
  case 2:
    reply = "Button state: " + String(buttonState) + "  " + msgStr;
    break;
  case 3:
    if (!moistureIndex) {
      reply =
          "Moisture: " + String(moistureHistory[dataSize - 1]) + "  " + msgStr;
    } else {
      reply = "Moisture: " + String(moistureHistory[moistureIndex - 1]) + "  " +
              msgStr;
    }
    break;
  case 4:
    if (!coreTempIndex) {
      reply = "Core temperature: " + String(coreTempHistory[dataSize - 1]) +
              "  " + msgStr;
    } else {
      reply =
          "Core temperature: " + String(coreTempHistory[coreTempIndex - 1]) +
          "  " + msgStr;
    }
    break;
  default:
    reply = "Command activated: " + commandSet[index] + "  " + msgStr;
  }

  if (fromWebhook) {
    sendMessage(reply);
  } else {
    mqttStr(reply);
  }
}

void handleRoot() {
  digitalWrite(led, 1);
  StreamString html;
  html.reserve(500); // Preallocate to avoid memory fragmentation
  html.printf("<html>\
  <head>\
    <title>" BOARD_NAME " Demo</title>\
    <style>\
      body { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088; }\
      a { color: #0000FF; text-decoration: none; }\
      a:hover { text-decoration: underline; }\
    </style>\
  </head>\
  <body>\
    <h1>Welcome to " BOARD_NAME " Demo</h1>\
    <p><a href=\"/coreTemperature\">Core Temperature</a></p>\
    <p><a href=\"/moistureValue\">Moisture Value</a></p>\
    <p><a href=\"/imageStream\">Image Stream</a></p>\
  </body>\
</html>");
  server.send(200, "text/html", html);
  digitalWrite(led, 0);
}

void handleCoreTemperature() {
  digitalWrite(led, 1);
  float coreTemp = analogReadTemp();                 // Read core temperature
  coreTempHistory[coreTempIndex] = analogReadTemp(); // Store the new reading

  int sec = millis() / 1000;
  int min = sec / 60;
  int hr = min / 60;

  StreamString response;
  response.reserve(1000); // Preallocate to avoid memory fragmentation
  response.printf("<html>\
  <head>\
    <meta http-equiv='refresh' content='5'/>\
    <title>Core Temperature</title>\
    <style>\
      body { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088; }\
      a { color: #0000FF; text-decoration: none; }\
      a:hover { text-decoration: underline; }\
    </style>\
  </head>\
  <body>\
    <h1>Core Temperature</h1>\
    <p>Current Core Temperature: %.2f &deg;C</p>\
    <p>Uptime: %02d:%02d:%02d</p>\
    <p>Free Memory: %d</p>\
    <p>Page Count: %d</p>\
    <img src=\"/test.svg?type=coreTemp\" />\
    <p><a href=\"/\">Back to Home</a></p>\
  </body>\
</html>",
                  coreTemp, hr, min % 60, sec % 60, rp2040.getFreeHeap(),
                  ++pageCount);
  server.send(200, "text/html", response);
  digitalWrite(led, 0);
}

void handleMoistureValue() {
  digitalWrite(led, 1);
  int moistureValue = analogRead(MOISTURE_PIN); // Read moisture value (0-1023)
  moistureHistory[moistureIndex] = moistureValue; // Store the new reading

  int sec = millis() / 1000;
  int min = sec / 60;
  int hr = min / 60;

  StreamString response;
  response.reserve(1000); // Preallocate to avoid memory fragmentation
  response.printf("<html>\
  <head>\
    <meta http-equiv='refresh' content='5'/>\
    <title>Moisture Value</title>\
    <style>\
      body { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088; }\
      a { color: #0000FF; text-decoration: none; }\
      a:hover { text-decoration: underline; }\
    </style>\
  </head>\
  <body>\
    <h1>Moisture Value</h1>\
    <p>Current Moisture Value: %d</p>\
    <p>Uptime: %02d:%02d:%02d</p>\
    <p>Free Memory: %d</p>\
    <p>Page Count: %d</p>\
    <img src=\"/test.svg?type=moisture\" />\
    <p><a href=\"/\">Back to Home</a></p>\
  </body>\
</html>",
                  moistureValue, hr, min % 60, sec % 60, rp2040.getFreeHeap(),
                  ++pageCount);
  server.send(200, "text/html", response);
  digitalWrite(led, 0);
}

void handleImageStream() {
  StreamString response;
  response.reserve(1000);
  response.printf("<html>\
  <head>\
    <meta http-equiv='refresh' content='5'/>\
    <title>Moisture Value</title>\
    <style>\
      body { background-color: #cccccc; font-family: Arial, Helvetica, Sans-Serif; Color: #000088; }\
      a { color: #0000FF; text-decoration: none; }\
      a:hover { text-decoration: underline; }\
    </style>\
  </head>\
  <body>\
    <h1>Real-time Webcam Stream(update image per 5s)</h1>\
    <img src='/imageFeed' />\
    <p><a href=\"/\">Back to Home</a></p>\
  </body>\
</html>");
  server.send(200, "text/html", response);
}

void imageFeed() {
  WiFiClient client = server.client();

  String url = "http://" + String(pythonServerIP) + ":" +
               String(pythonServerPort) + "/video_feed";
  http.begin(url);

  http.setTimeout(30000); // Increase timeout to 30 seconds
  http.begin(url);

  int httpCode = http.GET();

  unsigned long streamStartTime = millis();

  if (httpCode > 0) {
    Serial.println("Connected to Python server");
    client.println("HTTP/1.1 200 OK");
    client.println("Content-Type: multipart/x-mixed-replace; boundary=frame");
    client.println("Connection: close");
    client.println();

    WiFiClient *stream = http.getStreamPtr();

    while (http.connected() && client.connected()) {
      if (stream->available()) {
        int len = stream->available();
        uint8_t buffer[128] = {0};
        int bytesRead = stream->readBytes(buffer, min(len, sizeof(buffer)));
        client.write(buffer, bytesRead);
      }
      if (millis() - streamStartTime > 5000) {
        break;
      }
      yield(); // Allow the ESP32 to perform background tasks
    }
  } else {
    Serial.print("Failed to connect to Python server. Error code: ");
    Serial.println(httpCode);
    Serial.println(http.errorToString(httpCode).c_str());
    client.println("HTTP/1.1 503 Service Unavailable");
    client.println("Content-Type: text/plain");
    client.println();
    client.println("Failed to connect to video stream");
  }

  http.end();
}

void drawGraph() {
  String type = server.arg("type");
  String out;
  out.reserve(2600);
  out += "<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" "
         "width=\"400\" height=\"150\">\n";
  out += "<rect width=\"400\" height=\"150\" fill=\"rgb(250, 230, 210)\" "
         "stroke-width=\"1\" stroke=\"rgb(0, 0, 0)\" />\n";
  out += "<g stroke=\"black\">\n";

  int x = 10;
  int prevY = 0;

  if (type == "coreTemp") {
    prevY =
        140 - map(coreTempHistory[coreTempIndex % dataSize], 20, 30, 10, 130);
    for (int i = 1; i < dataSize; i++) {
      int y = 140 - map(coreTempHistory[(coreTempIndex + i) % dataSize], 20, 30,
                        10, 130);
      out += "<line x1=\"" + String(x) + "\" y1=\"" + String(prevY) +
             "\" x2=\"" + String(x + 10) + "\" y2=\"" + String(y) +
             "\" stroke-width=\"1\" />\n";
      prevY = y;
      x += 10;
    }
  } else if (type == "moisture") {
    prevY =
        140 - map(moistureHistory[moistureIndex % dataSize], 0, 1023, 10, 130);
    for (int i = 1; i < dataSize; i++) {
      int y = 140 - map(moistureHistory[(moistureIndex + i) % dataSize], 0,
                        1023, 10, 130);
      out += "<line x1=\"" + String(x) + "\" y1=\"" + String(prevY) +
             "\" x2=\"" + String(x + 10) + "\" y2=\"" + String(y) +
             "\" stroke-width=\"1\" />\n";
      prevY = y;
      x += 10;
    }
  }

  out += "</g>\n</svg>\n";
  server.send(200, "image/svg+xml", out);
}

void handleNotFound() {
  digitalWrite(led, 1);
  String message = "File Not Found\n\n";
  message += "URI: ";
  message += server.uri();
  message += "\nMethod: ";
  message += (server.method() == HTTP_GET) ? "GET" : "POST";
  message += "\nArguments: ";
  message += server.args();
  message += "\n";

  for (uint8_t i = 0; i < server.args(); i++) {
    message += " " + server.argName(i) + ": " + server.arg(i) + "\n";
  }

  server.send(404, "text/plain", message);
  digitalWrite(led, 0);
}

void generateQRCode(const char *text) {
  // Create a QR code object
  QRCode qrcode;

  // Define the size of the QR code (1-40, higher means bigger size)
  uint8_t qrcodeData[qrcode_getBufferSize(3)];
  qrcode_initText(&qrcode, qrcodeData, 3, 0, text);

  // Clear the display
  display.clearDisplay();

  // Calculate the scale factor
  int scale = min(SCREEN_WIDTH / qrcode.size, SCREEN_HEIGHT / qrcode.size);

  // Calculate horizontal shift
  int shiftX = (SCREEN_WIDTH - qrcode.size * scale) / 2;

  // Calculate horizontal shift
  int shiftY = (SCREEN_HEIGHT - qrcode.size * scale) / 2;

  // Draw the QR code on the display
  for (uint8_t y = 0; y < qrcode.size; y++) {
    for (uint8_t x = 0; x < qrcode.size; x++) {
      if (qrcode_getModule(&qrcode, x, y)) {
        display.fillRect(shiftX + x * scale, shiftY + y * scale, scale, scale,
                         WHITE);
      }
    }
  }

  // Update the display
  display.display();
}

void connectWiFi() {
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  Serial.println("Connecting to WiFi");

  // Wait for connection
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }

  Serial.println("");
  Serial.print("Connected to ");
  Serial.println(ssid);
  Serial.print("IP address: ");
  Serial.println(WiFi.localIP());
}

void connectMQTT() {
  Serial.println("Connecting to MQTT");
  while (!client.connected()) {
    Serial.print("Attempting MQTT connection...");
    // Attempt to connect
    if (client.connect(clientID, mqttUserName, mqttPwd)) {
      Serial.println("connected");
      // Once connected, subscribe to call topic
      client.subscribe(calltopic);
    } else {
      Serial.print("failed, rc=");
      Serial.print(client.state());
      Serial.println(" try again in 1 second");
      // Wait 1 second before retrying
      delay(1000);
    }
  }
}

void mqttStr(String msgStr) {
  if (millis() - prevMillis > interval) {
    prevMillis = millis();

    byte arrSize = msgStr.length() + 1;
    char msg[arrSize];
    msgStr.toCharArray(msg, arrSize);
    client.publish(topic, msg);
    Serial.print("Published message: ");
    Serial.println(msg);
  }
}

void callback(char *topic, byte *payload, unsigned int length) {
  commandStr = "M";
  Serial.print("Message arrived [");
  Serial.print(topic);
  Serial.print("] ");
  for (unsigned int i = 0; i < length; i++) {
    commandStr += (char)payload[i];
  }
  Serial.println(commandStr);

  // Handle message
  // if ((char)payload[0] == '1') {
  //     digitalWrite(led, HIGH);
  // } else {
  //     digitalWrite(led, LOW);
  // }
}

void sendMessage(String message) {
  HTTPClient http;

  // Use push message endpoint instead of broadcast
  http.begin(lineClient, "https://api.line.me/v2/bot/message/push");

  http.addHeader("Content-Type", "application/json");
  http.addHeader("Authorization", String("Bearer ") + accessToken);

  // Create the JSON payload
  JsonDocument doc;
  doc["to"] = userId; // Specify the user to send to
  JsonArray messages = doc["messages"].to<JsonArray>();
  JsonObject msg = messages.add<JsonObject>();
  msg["type"] = "text";
  msg["text"] = message;

  String payload;
  serializeJson(doc, payload);

  Serial.println("Sending message...");
  Serial.println(payload);

  int httpResponseCode = http.POST(payload);

  if (httpResponseCode > 0) {
    String response = http.getString();
    Serial.println("HTTP Response code: " + String(httpResponseCode));
    Serial.println("Response: " + response);
  } else {
    Serial.print("Error code: ");
    Serial.println(httpResponseCode);
    Serial.println(http.errorToString(httpResponseCode));
  }

  http.end();
}

void handleWebhook() {
  if (server.method() == HTTP_POST) {
    String payload = server.arg("plain");
    Serial.println("Received webhook payload: " + payload);

    // Parse the JSON payload
    JsonDocument doc;
    deserializeJson(doc, payload);

    // Extract the message text
    String messageText = doc["events"][0]["message"]["text"];
    String replyToken = doc["events"][0]["replyToken"];

    commandStr = "L";
    commandStr += messageText;

    Serial.println("Received message: " + messageText);

    // Send a reply
    sendReply(replyToken, "You said: " + messageText);

    server.send(200, "text/plain", "OK");
  } else {
    server.send(405, "text/plain", "Method Not Allowed");
  }
}

void sendReply(String replyToken, String message) {
  HTTPClient http;

  http.begin(lineClient, "https://api.line.me/v2/bot/message/reply");

  http.addHeader("Content-Type", "application/json");
  http.addHeader("Authorization", String("Bearer ") + accessToken);

  // Create the JSON payload
  JsonDocument doc;
  doc["replyToken"] = replyToken;
  JsonArray messages = doc["messages"].to<JsonArray>();
  JsonObject msg = messages.add<JsonObject>();
  msg["type"] = "text";
  msg["text"] = message;

  String payload;
  serializeJson(doc, payload);

  Serial.println("Sending reply...");
  Serial.println(payload);

  int httpResponseCode = http.POST(payload);

  if (httpResponseCode > 0) {
    String response = http.getString();
    Serial.println("HTTP Response code: " + String(httpResponseCode));
    Serial.println("Response: " + response);
  } else {
    Serial.print("Error code: ");
    Serial.println(httpResponseCode);
    Serial.println(http.errorToString(httpResponseCode));
  }

  http.end();
}

String convertEpochTime(long epoch) {
  static const int daysPerMonth[] = {31, 28, 31, 30, 31, 30,
                                     31, 31, 30, 31, 30, 31};
  static const int daysPerYear = 365;
  static const int daysPerLeapYear = 366;

  int year = 1970, month = 0, day = 0;
  long days = epoch / (24 * 60 * 60);

  while (days >= 0) {
    int daysInCurrentYear =
        (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0))
            ? daysPerLeapYear
            : daysPerYear;
    if (days < daysInCurrentYear) {
      break;
    }
    days -= daysInCurrentYear;
    year++;
  }

  for (int i = 0; i < 12; i++) {
    int currentMonthLength = daysPerMonth[i];
    if (i == 1 && (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0))) {
      currentMonthLength++; // February in a leap year
    }
    if (days < currentMonthLength) {
      month = i;
      day = days + 1; // Days are 0-based in the calculation
      break;
    }
    days -= currentMonthLength;
  }

  return "Current time : " + String(year) + "/" + String(month + 1) + "/" +
         String(day);
}